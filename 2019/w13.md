# 如何使用 ```Go``` 中 ```context``` 终止功能

- 原文地址:https://www.sohamkamani.com/blog/golang/2018-06-17-golang-using-context-cancellation/
- 原文作者: [Soham Kamani](https://www.packtpub.com/books/info/authors/soham-kamani)
- 译文出处: https://www.sohamkamani.com
- 本文永久链接: https://github.com/gocn/translator/blob/master/2019/w13.md
- 译者: [yufeng0924](https://github.com/yufeng0924)
- 校对者:

很多使用```Go```的用户将会在工作中碰到```context```这个库. ```context``` 更多的情况下应用在数据下游的处理上. 例如发起一个```Http``` 的请求或者从 ```DataBase``` 获取数据, 又或者需要对 ```go-routines``` 的执行性能做分析. ```context``` 更多的作用是通过向下游传输公共数据并且可以应用在所有的下游数据操作上. 然后,或许很少人知道. ```context``` 一个很重要的功能是可以在程序运行中进行终止和暂停操作.
本文中我们会介绍如何使用 ```context``` 中终止这一重要功能. 我们会通过一些流程图和简单的代码示例, 看如何让我们的应用(程序)更快并且更稳定.
## 我们为什么需要一个终止命令
总之, 我们为了防止我们的系统做一些不必须要的工作.
让我们来考虑这样一个场景, 一个 ```http``` 的 ```web``` 服务去请求数据库并且返回查询给用户(客户端). 如下图所示:

![](https://www.sohamkamani.com/client-diagram-199c2b8faf7663c9b7e83de127012a6c.svg )

如果这个请求是正常执行的, 整个请求的生命周期如下图所示:

![](https://www.sohamkamani.com/timing-ideal-ff6e4d831668b9da81c1c214224e4521.svg)

但是如果客户端突然中止了请求会发生什么样的情况? 这种情况是容易出现的,例如: 用户突然关闭了浏览器在数据请求过程中. 如果没有终止, 那么服务器和数据库将继续继续一些列的操作. 在终止之后的服务器操作其实是一个资源上的浪费.

![](https://www.sohamkamani.com/timing-without-cancel-4955e194034f42b5edd7632f1461c124.svg)

理想状态下, 我们是希望在客户端发生中断之后后续的所有资源都将终止. 如下图所示, 所有的节点上的工作将会全部终止(包括 ```http``` 的了解和数据库的操作)

![](https://www.sohamkamani.com/timing-with-cancel-2af484f735aab3022ea8d7a9a9c1b675.svg)

## 下面我们进入正文, 在```Go```中如何用```context```中的终止功能.

现在我们已经明确了我们的目的, 就是为什么我们要有终止的操作,下面让我们看下如何用 ```Go``` 来实现该功能.
因为这个终止的事件是一个和上下文紧密相关的在一个事物里, 或者这个操作已经被执行完了. 这仅是一个原生的功能绑在了 ```context``` 上.

这里有 2 个地方或许你需要去实现来达到终止的效果.
- 监听这个终止的事件.
- 发出终止的命令.

## 如何监听到终止的事件

```context``` 类型提供了一个 ```Done()``` 的方法,这个方法会返回一个空的结构体,这个结构体会接收到每次终止的指令. 要监听终止的事件 通过 使用 ```<- ctx.Done()```是非常容易的一个事.

下面我们来实现一个例子, 让我们考虑下,如果有这样一个的 ```Web``` 服务,每次处理一个请求的事件需要花费 2 秒钟, 我们的预期结果是立即返回一个数据当在正常请求完成之前收到了终止指令.

代码如下:
```go
func main() {
	// Create an HTTP server that listens on port 8000
	http.ListenAndServe(":8000", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		// This prints to STDOUT to show that processing has started
		fmt.Fprint(os.Stdout, "processing request\n")
		// We use `select` to execute a peice of code depending on which
		// channel receives a message first
		select {
		case <-time.After(2 * time.Second):
			// If we receive a message after 2 seconds
			// that means the request has been processed
			// We then write this as the response
			w.Write([]byte("request processed"))
		case <-ctx.Done():
			// If the request gets cancelled, log it
			// to STDERR
			fmt.Fprint(os.Stderr, "request cancelled\n")
		}
	}))
}
```
所有代码的示例可以在这里找到 https://github.com/sohamkamani/blog-example-go-context-cancellation 

现在我们可以启动这个服务,并且在浏览器访问 localhost:8000, 然后在 2 秒以内进行关闭浏览器的操作,我们会在终端看到 "request cancelled" 打印的结果.

## 发起一个终止的命令

如果你正在操作某些资源,需要发起终止命令的时候,你可以通过 ```context``` 来发起这个终止操作.我们可以使用 ```context``` 包中的 ```WithCance``` 命令,它会返回一个```Object```类型,该类型中有一个方法,我们不需要传递任何参数,直接调用该方法,也不会需要接收任何的返回值.

让我们考虑这样一个应用场景,该操作需要 2 个依赖关系(类似于 ```Mysql``` 的事物操作)其中一个失败了. 另外一个操作其实是没有必须继续的. 如果我们知道其中一个失败了. 我们是希望把之前的其他操作进行一个终止的.
让我们看下具体实现.

代码如下:
```go
func operation1(ctx context.Context) error {
	// Let's assume that this operation failed for some reason
	// We use time.Sleep to simulate a resource intensive operation
	time.Sleep(100 * time.Millisecond)
	return errors.New("failed")
}

func operation2(ctx context.Context) {
	// We use a similar pattern to the HTTP server
	// that we saw in the earlier example
	select {
	case <-time.After(500 * time.Millisecond):
		fmt.Println("done")
	case <-ctx.Done():
		fmt.Println("halted operation2")
	}
}

func main() {
	// Create a new context
	ctx := context.Background()
	// Create a new context, with its cancellation function
	// from the original context
	ctx, cancel := context.WithCancel(ctx)

	// Run two operations: one in a different go routine
	go func() {
		err := operation1(ctx)
		// If this operation returns an error
		// cancel all operations using this context
		if err != nil {
			cancel()
		}
	}()

	// Run operation2 with the same context we use for operation1
	operation2(ctx)
}
```

## 基于时间的终止

任何的应用和服务都需要维护一个最大的请求影响时间: 服务相应一致性```(SLA (service level agreement) )```. 我们需要根据相应时间来做出一些判断是否需要终止某些服务.

下面这段 ```API``` 和前面的 ```API``` 是一样的,只是加了一些额外的代码.
```go
// The context will be cancelled after 3 seconds
// If it needs to be cancelled earlier, the `cancel` function can
// be used, like before
ctx, cancel := context.WithTimeout(ctx, 3*time.Second)

// The context will be cancelled on 2009-11-10 23:00:00
ctx, cancel := context.WithDeadline(ctx, time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC))
```
例如我们的服务中有依赖于第三方的请求, 我们可能需要提前去取消这个依赖请求如果第三方的服务不稳定或者影响的时间过长.

```go
func main() {
	// Create a new context
	// With a deadline of 100 milliseconds
	ctx := context.Background()
	ctx, _ = context.WithTimeout(ctx, 100*time.Millisecond)

	// Make a request, that will call the google homepage
	req, _ := http.NewRequest(http.MethodGet, "http://google.com", nil)
	// Associate the cancellable context we just created to the request
	req = req.WithContext(ctx)

	// Create a new HTTP client and execute the request
	client := &http.Client{}
	res, err := client.Do(req)
	// If the request failed, log to STDOUT
	if err != nil {
		fmt.Println("Request failed:", err)
		return
	}
	// Print the statuscode if the request succeeds
	fmt.Println("Response received, status code:", res.StatusCode)
}
```
这个服务会依赖于 ```Google``` 的首页相应时间. 多次请求你回收到不同的返回结果. (国内用户可以修改任意可以访问的地址)
- Response received, status code: 200

或者是

- Request failed: Get http://google.com: context deadline exceeded

你可以调整 ```timeout``` 的设置来达到上面 2 个情况的效果.

## 理解该功能和一些建议忠告

尽管终止命令是 ```context``` 一个通用的功能, 但是有一些情况你需要特别注意在你开始在代码里加入或者已经使用了该功能.
- 终止操作在 ```context``` 中只可以使用一次.
如果有很多的失败的信息在一个操作中, 你希望通过 ```context``` 终止命令去广播到每一个操作, 用 ```context``` 不是一个最好的选择.
在使用之前你应该很清楚的知道你要终止的是什么操作,而不是简单地告知下游数据这里有一个错误出现了.

第二个情况是你应该把相通的上下文传递给所有使用该上下文的函数和 ```go-routine```. 当使用 ```WithTimeout``` 和 ```WithCancel``` 去操作一个已经被取消的 ```context``` 的包的时候会发生很多可能性,这个是需要进行避免的.






